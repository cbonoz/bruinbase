######################################
# CS143 Database System              #
# Project 2A, Bruinbase System       #
# Chris Buonocore, SID: 904587506    #
# Zengwen Yuan, SID: 604593014       #
# Ver 1.1, Nov. 5th 2015             #
######################################

This is the readme file for Project 2A of CS143.


##<Overview>

In this part, we implemented the bulk LOAD command, similar to the LOAD DATA command in MySQL for Project 1B. For Bruinbase, the syntax to load data into a table is:

	LOAD tablename FROM 'filename' [ WITH INDEX ]


##<Objective>

The main objective of this project is:
+ implement SqlEngine::load(table, loadfile, index) function with the user-provided table name and the load file name as its parameters


##<Implementation>

Following the functional headers in SqlEngine.h and the instruction on project specification, we are dealing with the command:

	LOAD movie FROM 'movie.del'

thus, we have to open two files using open:
a) the `movie.del' file
b) the `movie.tbl' file we are creating

We first read the content of `movie.del' file using getline(), then call parseLoadLine() to parse the line input and extract the <key, value> pair, and use append(key, value, rid) to add the <key, value> pair to the `movie.tbl' file.

Finally, we close the files to save the results.

One tricky case we successfully handled is the empty line in the `movie.del' file. We used `empty()' function to check whther `getline()' returns an empty line so that we can discard it.

Also, when compiling the code we've got an error [C++ ifstream error using string as opening file path](http://stackoverflow.com/questions/6323619/c-ifstream-error-using-string-as-opening-file-path)

	SqlEngine.cc:144:23: error: no matching function for call to ‘std::basic_ifstream<char>::basic_ifstream(const string&)’
	   ifstream rf(loadfile); // RecordFile for the load file

which can be fixed by using
	ifstream rf(loadfile.c_str());

Because the constructor for an ifstream takes a const char*, not a string pre-C++11. 


## <Test Results>

First, we renamed the original table to `movie_orginal.tbl'.

Then, we entered the bruinbase and issued the load command, and the sample queries:
$ ./bruinbase 
Bruinbase> load movie from 'movie.del'
Bruinbase> select * from movie where key > 1000 and key < 1010
1008 'Death Machine'
1002 'Deadly Voyage'
1004 'Dear God'
1003 'Deal of a Lifetime'
1009 'Death to Smoochy'
  -- 0.000 seconds to run the select command. Read 403 pages
Bruinbase> select count(*) from movie
3616
  -- 0.000 seconds to run the select command. Read 403 pages
Bruinbase> select * from movie where key=3421
3421 'Remember the Titans'
  -- 0.010 seconds to run the select command. Read 403 pages
Bruinbase> select * from movie where value='Die Another Day'
1074 'Die Another Day'
  -- 0.000 
Bruinbase> quit

Last, we compared the binary files generated by our program against the original one:
$ diff movie.tbl movie_original.tbl
$

which the output is empty so that two binary files are exactly the same.

Thus, our implementation is correct.
